{"build_dependencies":{"math":"ipfs://testipfs-math"},"contract_types":{"Address":{"abi":[],"compiler":{"name":"solc","settings":{"optimize":false},"version":"0.5.10+commit.5a6ea5b1"},"deployment_bytecode":{"bytecode":"0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820c2655e214fd755915d3eaf4b3015e6355a957a280ca8314f4e848a9e2e2eb39064736f6c634300050a0032"},"natspec":{"details":"Collection of functions related to the address type","methods":{}},"runtime_bytecode":{"bytecode":"0x73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820c2655e214fd755915d3eaf4b3015e6355a957a280ca8314f4e848a9e2e2eb39064736f6c634300050a0032"}},"Arrays":{"abi":[],"compiler":{"name":"solc","settings":{"optimize":false},"version":"0.5.10+commit.5a6ea5b1"},"deployment_bytecode":{"bytecode":"0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723058203f6d6ee75fd55d347a3f81fd49cb2dc0aacd7d2d03f2964b946874ffb17fa93964736f6c634300050a0032"},"natspec":{"details":"Collection of functions related to array types.","methods":{}},"runtime_bytecode":{"bytecode":"0x73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723058203f6d6ee75fd55d347a3f81fd49cb2dc0aacd7d2d03f2964b946874ffb17fa93964736f6c634300050a0032"}},"ReentrancyGuard":{"abi":[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"compiler":{"name":"solc","settings":{"optimize":false},"version":"0.5.10+commit.5a6ea5b1"},"deployment_bytecode":{"bytecode":"0x"},"natspec":{"details":"Contract module that helps prevent reentrant calls to a function. * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them. * Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not call one another. This can be worked around by making those functions `private`, and then adding `external` `nonReentrant` entry points to them.","methods":{}},"runtime_bytecode":{"bytecode":"0x"}}},"manifest_version":"2","meta":{"authors":["OpenZeppelin Community <maintainers@openzeppelin.org>"],"description":"Miscellaneous contracts containing utility functions, often related to working with different data types. Sept. 30, 2019","keywords":["solidity","ethereum","smart","contracts","security","zeppelin"],"license":"MIT","links":{"documentation":"https://docs.openzeppelin.com/contracts/2.x/","repo":"https://github.com/OpenZeppelin/openzeppelin-contracts","website":"https://openzeppelin.com/contracts/"}},"package_name":"utils","sources":{"./utils/Address.sol":"pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n}","./utils/Arrays.sol":"pragma solidity ^0.5.0;\n\nimport \"math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n   /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}","./utils/ReentrancyGuard.sol":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}"},"version":"1.0.0"}
